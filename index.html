<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox Image to Binary</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            color: #000000;
            transition: background-color 0.3s, color 0.3s;
        }
        body.dark-mode {
            background-color: #121212;
            color: #ffffff;
        }
        h1 {
            text-align: center;
        }
        #output {
            background-color: #f0f0f0;
            color: #000000;
            padding: 10px;
            border: 1px solid #ccc;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        body.dark-mode #output {
            background-color: #1e1e1e;
            color: #ffffff;
            border-color: #333;
        }
        button, input {
            display: block;
            margin: 10px auto;
            padding: 10px;
            font-size: 16px;
        }
        button {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Roblox Image to Binary Converter</h1>
    <input type="text" id="imageUrl" placeholder="Enter Roblox Decal URL">
    <button onclick="processImage()">Convert</button>
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
    <pre id="output"></pre>

    <script>
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
        }
        async function processImage() {
    const input = document.getElementById('imageUrl').value;
    const assetId = input.replace('rbxassetid://', '').trim();

    const imageUrl = `https://assetdelivery.roblox.com/v1/asset/?id=${assetId}`;
    console.log("Image URL:", imageUrl);

    try {
        const response = await fetch('https://roblox-image-to-binary.onrender.com/process', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: imageUrl })
        });

        if (!response.ok) {
            throw new Error(`Error: ${response.statusText}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        const outputElement = document.getElementById('output');
        outputElement.textContent = ''; // Clear previous output

        const MAX_LINES = 100; // Limit the number of lines displayed
        const buffer = []; // Store recent lines

        let receivedText = '';
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            receivedText += decoder.decode(value, { stream: true });
            const lines = receivedText.split('\n');

            for (let i = 0; i < lines.length - 1; i++) {
                const line = lines[i];
                if (line.trim()) {
                    const batch = JSON.parse(line);
                    buffer.push(JSON.stringify(batch, null, 2));

                    // Keep only the latest MAX_LINES
                    if (buffer.length > MAX_LINES) {
                        buffer.shift(); // Remove the oldest line
                    }

                    // Update the display
                    outputElement.textContent = buffer.join('\n');
                }
            }

            receivedText = lines[lines.length - 1]; // Keep the last incomplete line
        }

        if (receivedText.trim()) {
            const batch = JSON.parse(receivedText);
            buffer.push(JSON.stringify(batch, null, 2));
            if (buffer.length > MAX_LINES) {
                buffer.shift();
            }
            outputElement.textContent = buffer.join('\n');
        }
    } catch (error) {
        document.getElementById('output').textContent = `Error: ${error.message}`;
    }
}

    </script>
</body>
</html>
